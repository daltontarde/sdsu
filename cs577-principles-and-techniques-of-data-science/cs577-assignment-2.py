# -*- coding: utf-8 -*-
"""cs577-assignment-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HT25hq1rtHZjPX3zOsNsLovBxlA6Cb82

# Assignment 3: EDA, Visualization, Regular Expressions, and SQL
## Due Date: Sunday, Oct. 31, 11:59PM

## Collaboration Policy

Data science is a collaborative activity. While you may talk with others about
the homework, we ask that you **write your solutions individually**. If you do
discuss the assignments with others please **include their names** below.

## Scoring Breakdown

|Question|Points|
|---|---|
|1.1|10|
|1.2|10|
|1.3|10|
|1.4|10|
|2|30|
|3.1|10|
|3.2|10|
|3.3|10|
|**Total**|100|

Load the Food Safety datasets (bus.csv, ins2vio.csv, ins.csv, and vio.csv) into pandas dataframes and answer the following questions based on the dataframes.
"""

import pandas as pd
import numpy as np
bus = pd.read_csv('bus.csv')
ins = pd.read_csv('ins.csv')
ins2vio = pd.read_csv('ins2vio.csv')
vio = pd.read_csv('vio.csv')

"""## Part 1: EDA

Use the business dataset (bus) to answer the Part 1 questions.

1.1. Examining the entries in `bus`, is the `bid` unique for each record (i.e. each row of data)?

Hint: use `value_counts()` or `unique()` to determine if the `bid` series has any duplicates.
"""

bid = bus['business id column'].value_counts().to_frame() # used value_counts() to find duplicates
bid[(bid['business id column'] != 1)]

"""1.2. In the two cells below create the following **two numpy arrays**:

1. Assign `top_names` to the top 5 most frequently used business names, from most frequent to least frequent.
2. Assign `top_addresses` to the top 5 addressses where businesses are located, from most popular to least popular.

Hint: you may find `value_counts()` helpful.
"""

top_names = bus['name'].value_counts().head(5)
top_names = top_names.to_frame().T.columns.to_numpy()
top_names

top_addresses = bus['address'].value_counts().head(5).iloc[1:] # removed "Off the Grid" - outlier
top_addresses.to_frame().T.columns.to_numpy()

"""1.3. In the following cell, construct a series that counts the number of businesses at each address that have likely MISSING postal code value (i.e. postal_code=-9999). Order the series in descending order by count."""

missing = bus[bus['postal_code'] == '-9999']
missing['address'].value_counts()

"""1.4. Look at the businesses that DO NOT have the special MISSING ZIP code value. Some of the invalid postal codes are just the full 9 digit code rather than the first 5 digits. Create a new column named `postal5` in the original bus dataframe which contains only the first 5 digits of the postal_code column. Finally, for any of the likely MISSING postal5 ZIP code entries set the entry to None."""

bus['postal5'] = bus['postal_code'].str[:5]
bus['postal5'].replace({"-9999" : None}, inplace = True)
bus

bus.head(6001).tail(1) #postal5

#bus = bus["postal5"].str.find("None")
bus.head(23).tail(1) # first instance of postal5 = "None" when iterating through bus DataFrame

"""## Part 2: Visualization

Using the four Food Safety datasets bus.csv, ins2vio.csv, ins.csv, and vio.csv:

2.Create a side-by-side boxplot like what you see in the figure that shows the distribution of the restaurant scores for each different risk category from 2017 to 2019. Use a figure size of at least 12 by 8.

Hint: Consider using appropriate JOIN operations.

![image.png](attachment:34b56649-30c9-452d-8300-a14ffa9a3580.png)
"""

import matplotlib.pyplot as plt
import seaborn as sns

scores = pd.merge(vio, ins2vio, how = 'left')
scores = pd.merge(scores, ins, how = 'left')
dataByYear = r'\/(\d{4})\s'
scores['year'] = scores['date'].str.extract(dataByYear)

scores = scores[scores['year'] != '2016'] # 2017-2019
scores['score'] = scores[scores['score'] > 40].score

sns.set(rc = {'figure.figsize':(20, 20)})
sns.boxplot(x = 'year', y = 'score', hue = 'risk_category', data = scores, hue_order = ['Low Risk', 'Moderate Risk', 'High Risk'])

"""## Part 3: SQL

3.1 Create a database `Cat` with the following schema:

CREATE TABLE owners (

ownerid integer,

name text,

age integer,

PRIMARY KEY (ownerid)

);


CREATE TABLE cats (

catid integer,

owner integer,

name text,

breed text,

age integer,

PRIMARY KEY (catid),

FOREIGN KEY (owner) REFERENCES owners);
"""

import sqlite3
cat = sqlite3.connect(':memory:')
c = cat.cursor()

c.execute("""
CREATE TABLE owners (
  ownerid integer,
  name text,
  age integer,
  PRIMARY KEY (ownerid)
);
""")

c.execute("""
CREATE TABLE cats (
  catid integer,
  owner integer,
  name text,
  breed text,
  age integer,
  PRIMARY KEY (catid),
  FOREIGN KEY (owner) REFERENCES owners
);
""")

c.execute("""
INSERT INTO owners VALUES
    (0, 'Abe', 30),
    (1, 'Jullana', 20),
    (2, 'Zane', 10);
""")

c.execute("""
INSERT INTO cats VALUES
    (0, 1, 'Genji', 'Devon Rex', 2),
    (1, 1, 'Tiger', 'Tabi', 4),
    (2, 1, 'Mr. Mittens', 'Siamese', 6),
    (3, 1, 'Sphynx', 'Sphynx', 8),
    (4, 1, 'Meowth', 'Mainecoon', 11),
    (5, 1, 'Kit Kat', 'Persian', 15);
""")

cat.commit()

"""3.2. Write a SQL query that returns the number of cats, over the age of 10, of each
breed of cat.
"""

count = 0
def print_sql(s):
    for result in c.execute(s):
        global count
        count += 1
        print(result)

query1 = """
  SELECT * FROM cats
  WHERE age > 10
  GROUP BY breed;
"""

print_sql(query1)
print() # line break
print("Number of cats over age 10: " + str(count) + " cats")

"""3.3. Write a SQL query that returns the ownerid/owner of the one cat owner who owns
the most cats.
"""

query2 = """
  SELECT owners.ownerid, owners.name FROM owners
  INNER JOIN cats ON owners.ownerid = cats.owner
  GROUP BY ownerid
  ORDER BY COUNT(*) DESC
  LIMIT 1;
"""
print_sql(query2)